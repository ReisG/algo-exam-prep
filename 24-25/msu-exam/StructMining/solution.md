# Решение задачи StructMining: Добыча структур (60 баллов)

## Размышление

`char nums[24]` из 2) и 7)  
Из выражения 2) становится ясно, что в `a.nums` >= 14 элементов, а из утверждения 7), что массив занимается 24 байта. Следовательно это `char nums[24]`, так как если взять следующий по размеру тип `short`, занимающий 2 байта, максимальное количество элементов будет равно `24 / 2 = 12`.  
В выражении 2) `char + char` как раз дают `int`.

`void *a.z` из 5) и 8)  
Из выражений 5) и 8) `a.z` не может быть ни `int *`, ни `char *`, так как вызовет предупреждение, но может быть `void *`.

`unsigned long a.n` из 4)  
Из выражения 4) выясняется, что происходит переполнение в `a.n`, из-за чего оно становится большим `UINT_MAX`. Такое может случится при вычитании только с `unsigned` типом. `UINT_MAX = 0xffffffff` по размеру 4 байт, следовательно нам подходит больший по размеру `long` или `long long`.

`struct S *x` из 1)  
Из выражения 1) переменной `a` присвоить `a.x` следовательно, они одинаковых типов, только `a.x` ссылка. Также размер структуры S равен 48 байтам.

Выражение 3) даёт информацию о том, что `a.x` стоит позже (имеет больший номер) `a.z` на 8 байт, а поскольку заполняющих байтов быть не должно, то это размер какого-то типа из структуры, например самого `void *a.z`, который как раз равен 8 байтам, значит `a.x` следует сразу после `a.z`.

Выражение 6) даёт информацию о том, что `a.z` стоит позже (имеет больший номер) `a.n` на 32 байта, такой большой размер может дать массив, значит следует предположить, что `a.n` стоит до `a.nums`, а `a.z` после.

## Ответ

```c
struct S {
    unsigned long long n;
    char nums[24];
    void *z;
    struct S *x;
};
```

### Удобный код для подбора ответа:

```c
#include <stdio.h>
#include <stdlib.h>

struct S {
    // x
    // z
    // n
    // nums
} a = {0};

char *x;
int *z;

int main(void) {
    printf("1. %llu\n", sizeof(a = *a.x));
    printf("2. %d\n",   a.nums[13] + a.nums[1]);
    printf("3. %lld\n", (char *)&a.x - (char *)&a.z);
    printf("4. %d\n",   (a.n = -1) > UINT_MAX);
    printf("5. %d\n",   z = a.z);
    printf("6. %lld\n", (char *)&a.z - (char *)&a.n);
    printf("7. %llu\n", sizeof(a.nums));
    printf("8. %d\n",   x = a.z);
}
```

### Дополнительная инфмормация:

```c
┌───────────┬──────────┐
│ Тип       │ Формат   │
├───────────┼──────────┤
│ int       │ %d       │
│ int *     │ %d       │
│ char *    │ %d       │
│ size_t    │ %llu     │
│ ptrdiff_t │ %lld     │
└───────────┴──────────┘

Для других типов смотрите предупреждение при компиляции.
```